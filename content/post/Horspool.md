---
title: "Horspool子串搜索算法"
date: 2025-10-30
timezone: UTC+8
tags: ["算法","字符串","子串搜索","Boyer-Moore算法","Horspool算法"]
categories: ["算法原理"]
draft: false
math: true
---

Horspool算法是一种高效的字符串子串搜索算法，它是Boyer-Moore算法的简化改进版本。

## 算法描述

现在假设我们要在一个长字符串`T = "ATATCTACATATAC"`中搜索一个模式字符串`P = ATATA`，Horspool算法的基本思路是：

1. 初始化一个`skip[256]`数组。什么是`skip[256]`数组？对于模式串`P`，我们计算其中每一个字符到最后一个字符的距离，若出现重复的字符，则按照距离最后一个字符最近的一个字符的距离来算，例如我们的字符串`"ATATA"`，其中每一个字符串对应的距离为`[2,1,2,1]`，为什么只有四个距离？因为最后一个字符到其本身的距离为0，所以不进行计算，这时候就需要我们初始化一个固定值的`skip[256]`数组，每个元素初始化为`P`的长度5（即，没出现在模式串中的字符距离全部为5），此时距离数组变为`[2,1,2,1,5]`，那么`skip[256]`数组如何对距离进行储存？

2. 将模式串`P`推广到n个字符，按照字符数组的索引，`P`的索引为0到n-1，因此第i个字符到最后一个字符的距离为n-1-i，因此我们可以将`skip[P[i]]`的值更新为`n-1-i`，由于`P[i]`的值为字符的ASCII码，所以我们才定义`skip[256]`数组的长度为256（128个标准ASCII码，但是存在扩展ASCII码，因此256为最保险的长度，包含所有情况）。

3. 初始化完成后，开始horspool的正式过程。我们继续使用上面定义的两个字符串，现在先将模式串对齐到`T`的起始位置进行比对：  
    ```shell
    T = "ATATCTACATATAC"
    P = "ATATA"
    ```
    从右向左比对，长串第一个`C`对不上模式串第一个`A`，我们只关注最后一位的距离，查`skip`表，发现`C`不存在模式串中，因此距离为5，所以我们将模式串全部向右跳转五个距离：
    ```shell
    T = "ATATCTACATATAC"
    P =      "ATATA"
    ```
    继续进行比对，发现模式串最后一位`A`依然对不上长串的对应字符`T`，同样的，只关注最后一位的距离，查`skip`表，发现`T`的距离为1，因此我们将模式串全部向右跳转一个距离：
    ```shell
    T = "ATATCTACATATAC"
    P =       "ATATA"
    ```
    这一次我们发现对得上的字符很多，从右向左，第一个对不上的字符是`C`和`T`，但是我们只关注最后一位的距离，最后一位是`A`，查表，`A`的距离为2，因此我们将模式串全部向右跳转两个距离：
    ```shell
    T = "ATATCTACATATAC"
    P =         "ATATA"
    ```
    完全匹配，搜索结束。

这就是Horspool算法的基本过程，通过查找对不上的字符，比对最后一位的距离进行快速跳转，从而查找出所有匹配的子串。

## 代码实现

```c++
int horspool(char *T, int n, char *P, int m) {
    int i, j;
    for (i = 0; i < 256; i++) skip[i] = m;
    for (i = 0; i < m-1; i++) skip[P[i]] = m-1-i;
    
    i = 0;
    while (i <= n-m) {
        for (j = m-1; j >= 0 && P[j] == T[i+j]; j--);
        if (j < 0) return i;
        i += skip[T[i+m-1]];
    }
    return -1;
}
```

## 时间复杂度

Horspool算法的时间复杂度平均为$O(n)$，属于较为高效的算法；当字符大量重复且不匹配时，每次只能跳转一个距离，因此效率较低，最坏情况下的时间复杂度为$O(nm)$。