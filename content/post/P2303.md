---
title: "【题解】（洛谷）P2303 [SDOI2012] Longge 的问题"
date: 2025-11-03T20:00:00+08:00
timezone: UTC+8
tags: ["算法","数论","欧拉函数","狄利克雷卷积","莫比乌斯反演"]
categories: ["题解"]
draft: false
math: true
---

# P2303 [SDOI2012] Longge 的问题

## 题目背景

Longge 的数学成绩非常好，并且他非常乐于挑战高难度的数学问题。

## 题目描述

现在问题来了：给定一个整数 $n$，你需要求出 $\sum\limits_{i=1}^n \gcd(i, n)$，其中 $\gcd(i, n)$ 表示 $i$ 和 $n$ 的最大公因数。

## 输入格式

输入只有一行一个整数，表示 $n$。

## 输出格式

输出一行一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```console
6
```

### 输出 #1

```console
15
```

## 说明/提示

#### 数据规模与约定

- 对于 $60 \\% $ 的数据，保证 $n\leq 2^{16}$。
- 对于 $100 \\% $ 的数据，保证 $1\leq n< 2^{32}$。

---

## 题解

>观察题目中的式子，不难发现我们要求的式子其实就是欧拉函数去掉互质条件的形式。

定义：

$$
S(n) = \sum_{i=1}^n gcd(i,n)
$$

直接计算这个和式显然非常复杂，可以使用分组求和的方法进行简化：  

设 $gcd(i,n)=g$ ，集合 $A_g= \lbrace i \in \lbrace 1,2,...,n \rbrace | gcd(i,n)=g \rbrace$ ，则有：

$$
S(n) = \sum_{g|n} \sum_{i \in A_g} gcd(i,n)
$$

在内部求和中，根据该集合的定义，我们有：
$$
\sum_{i \in A_g}gcd(i,n) = \sum_{i \in A_g} g = g \cdot |A_g|
$$

由于 $gcd(i,n)=g$ ，对于每个满足的 $i$ ，必须有 $g|n$ （ $g$ 必须为 $n$ 的约数），令 $i = g \cdot l$ ，则有 $gcd(i,n)=g$ 等价于 $gcd(l,\frac{n}{g})=1$ 。  


>**证明：**  
>设 $n = g \cdot m$ ，其中 $m = \dfrac{n}{g}$ ， $gcd(i,n)=g$ 意味着 $g|i，g|n$ ，对原式同除 $g$ ，有 $gcd(\frac{i}{g},\frac{n}{g})=1$  
>具体的，由于 $i=g \cdot l$，有 $$ gcd(i,n)=gcd(g \cdot l,g \cdot m)=g \cdot gcd(l,m)$$
>要求 $gcd(i,n)=g$ ，即求 $g \cdot gcd(l,m) = g$ ，即 $gcd(l,m)=1$ ；由于 $i$ 的取值范围为 $1 \leq i \leq n$ ，因此 $1 \leq l \leq \frac{n}{g} = m$ ，所以满足条件的 $l$ 的个数即为与 $m$ 互质的正整数的个数，即**欧拉函数 $\varphi(m)$** 。

此时，满足条件的 $l$ 个数正好为欧拉函数 **$\varphi(\dfrac{n}{g})$**，于是：

$$
S(n) = \sum_{g|n} g\cdot \varphi(\frac{n}{g})
$$

根据狄利克雷卷积的定义：

$$
(f \ast g)(n) = \sum_{d|n} f(d) \cdot g(\frac{n}{d})
$$

不难发现 $S(n)$ 就是恒等函数 $id$ 和欧拉函数 $\varphi$ 的狄利克雷卷积，所以有：

$$
S(n) = (id \ast \varphi)(n) = \sum_{g|n} id(g) \cdot \varphi(\frac{n}{g})
$$

根据莫比乌斯反演，可以得到

$$
\varphi(n) = \sum_{g|n} \mu(g) \cdot id(\frac{n}{g}) = n \sum_{g|n} \frac{\mu(g)}{g}
$$

代入 $\frac{n}{g}$ ，有：

$$
\varphi(\frac{n}{g}) = \frac{n}{g} \cdot \sum_{h|\frac{n}{g}} \frac{\mu(h)}{h}
$$

代入 $S(n)$ ，有：

$$
S(n) =  \sum_{g|n} g \cdot \left(\frac{n}{g} \cdot \sum_{h|\frac{n}{g}} \frac{\mu(h)}{h}\right) = n \sum_{g|n} \sum_{h|\frac{n}{g}} \frac{\mu(h)}{h}
$$

$g|n$ 和 $h|\frac{n}{g}$ 等价于 $h|n$ 和 $g|\frac{n}{h}$ ，因此：

$$
S(n) = n \sum_{h|n} \frac{\mu(h)}{h} \sum_{g|\frac{n}{h}} 1 
$$

其中 $\sum_{g|\frac{n}{h}} 1 $ 是约数个数函数，记作 $\tau(\frac{n}{h})$  

$id$ 、$\mu$ 、$\varphi$ 、$\tau$ 都是积性函数，且狄利克雷卷积保持积性。设数$n = p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}$，则有：

$$
S(n) = n \prod_{i=1}^r \left(\sum_{h|{p_i}^{k_i}} \frac{\mu(h)}{h} \cdot \tau(\frac{p_i^{k_i}}{h})\right)
$$

至此，可以开始最终化简，$h$ 作为 $p_i^{k_i}$ 的因子，取值为 $p^{j},(j=0,1,\cdots,k)$ ，我们知道莫比乌斯函数 $\mu(h)$ 只在当 $h$ 没有平方因子的时候非零，即 $j=0$ 或 $j=1$ 时有贡献：
- 当 $j=0$ 时，$h=1， \mu(1) = 1，\tau(\frac{p^k}{1}) = \tau(p^k) = k + 1$ ，当前项为 $1 \cdot (k+1)$
- 当 $j=1$ 时，$h=p$ ， $\mu(p) = -1$ ， $\tau(\frac{p^k}{p}) = \tau(p^{k-1}) = k$ ，当前项为 $\frac{-1}{p} \cdot k$
- 当 $j\geq 2$ 时 ，$\mu(p^j) = 0$

所以，内层求和为：

$$
(k+1)-\frac{k}{p} = 1+k\cdot(1-\frac{1}{p})
$$

原式变为：

$$
S(n) = n \prod_{i=1}^r \left(1+k_i\cdot(1-\frac{1}{p_i})\right)
$$

即，

$$
\sum_{i = 1}^n \gcd(i,n) = n \prod_{p|n} \left(1+k_p\cdot(1-\frac{1}{p})\right)
$$

使用题目中的数据进行验算：

$$
6 \cdot (1+1 \cdot (1-\frac{1}{2})) \cdot (1 + 1 \cdot (1-\frac{1}{3})) = 6 \cdot 1.5 \cdot \frac{5}{3} = 15
$$

满足题意。

### AC代码
```c++
#include <iostream>
#include <unordered_map>

using ll = long long;
using namespace std;

// 使用试除法进行质因数分解，存入键值对
unordered_map<ll, int> prime_decomposition(ll n) {
    unordered_map<ll, int> res;
    int cnt = 0;
    while (n % 2 == 0) {
        cnt++;
        n /= 2;
    }
    if (cnt > 0) {
        res[2] = cnt;
    }
    for (ll i = 3; i * i <= n; i += 2) {
        cnt = 0;
        while (n % i == 0) {
            cnt++;
            n /= i;
        }
        if (cnt > 0) {
            res[i] = cnt;
        }
    }
    if (n > 1) {
        res[n] = 1;
    }
    
    return res;
}

int main() {
    ll num;
    cin >> num;
    if (num == 1) {
        cout << 1 << endl;
        return 0;
    }
    auto decomp = prime_decomposition(num);
    ll result = num;
    for (const auto& [p, k] : decomp) {
        ll numerator = p + k * (p - 1);
        result = result / p * numerator;
    }
    cout << result << endl;
    return 0;
}
```


