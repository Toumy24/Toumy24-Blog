---
title: "字符串哈希与Rabin-Karp子串搜索算法"
date: 2025-10-30
tags: ["算法","哈希","字符串","子串搜索","Rabin-Karp算法"]
categories: ["算法原理"]
draft: false
math: true
---

## 字符串哈希

哈希算法，通俗的来说就是一种将任意长度明文加密为一个固定长度的密文或值的算法。  
对于字符串的哈希算法，则是将一个字符串映射为一个固定长度的整数值，通过比对哈希值来判断两个字符串是否相等。  

### 字符串哈希的基本思想

字符串哈希的实现是将字符串视为一个 $base$ 进制数，然后对其取模得到哈希值。  
对于一个长度为 $n$ 的字符串 $S=s_0s_1...s_{n-1}$，其哈希值可以表示为：

$$
H(S)=\sum_{i=0}^{n-1}s_i\times base^{n-1-i}\mod M
$$

这就是**字符串模数哈希函数**的基本形式。
其中，
- $base$ 是哈希函数的进制基数，通常取素数，如 233 ，131 ，101 等。
- $M$ 是大质数模数，用于防止哈希冲突。
- $s_i$ 是字符串 $S$ 的第 $i$ 个字符的 ASCII 码值。

#### 数学原理

要对字符串进行哈希运算可表示为多项式 $f(x)=s_0x^{n-1}+s_1x^{n-2}+...+s_{n-1}x^0$ ，其哈希值为 $f(base)\mod M$ 。

#### 哈希冲突

当两个不同的字符串有相同的哈希值时，称为**哈希冲突**。  
模数 $M$ 较小时，可能出现很多冲突，导致哈希表的性能下降。  
模数 $M$ 较大时，虽然仍然会出现冲突，但可能出现冲突概率较低，这是由于模数越大，哈希函数的输出值域越大（值域为 $M$ ），使得冲突的概率降低。

#### 降低哈希冲突风险——双值哈希

为减少哈希冲突，可以采用多值哈希，其中比较常用的是**双值哈希**，即

$$
H_1(S)=f(base_1)\mod M_1\newline
H_2(S)=f(base_2)\mod M_2
$$

最终哈希值为二元组 $(H_1(S),H_2(S))$ 。

## 字符串哈希在子串搜索中的应用——Rabin-Karp算法

>核心思想：滚动哈希（Rolling Hash）
>滚动哈希可以在 $O(1)$ 的时间内计算出子串的哈希值。

滚动哈希其实就是一种前缀和的应用，通过递推关系，使用前一次计算的值推导下一个值。
给定一个滚动窗口区间长度，例如长度为3的窗口，在 "abcde" 中滚动，滚动的过程如下：
1. 设 "abcde" 每个字符的值分别为 $a=1,b=2,c=3,d=4,e=5$ ，按照顺序得到一个多位数字 $12345$ 。
2. 窗口大小为3，从第一个字符开始滚动，此时为 "abc" ，即数字 $123$ 。
3. 向后滚动一位，此时为 "bcd" ，即数字 $234$ ，按照进位计算即为：
   1. 去掉最高位，$123-100=23$ 。
   2. 整体进位, $23\times100=230$ 。
   3. 加上最新的最低位数字，即加上字符 'd' 对应的数字 $4$ ，得到 $230+4=234$ 。
4. 以此类推，就是滚动哈希的步骤。

### 数学过程

由于模数哈希的效率低下（可能频繁发生哈希冲突），因此我们使用双哈希的RK算法。

定义以下符号：
- 文本字符串 $T=t_0t_1...t_{n-1}$ ，长度为 $n$ 。
- 模式字符串 $P=p_0p_1...p_{m-1}$ ，长度为 $m$ 。
- 基数 $B_1 = 131$ ， $B_2 = 13131$ 。
- 模数 $M_1 = 1000000007$ ， $M_2 = 1000000009$ 。
- 字符c的ASCII码 $ord(c)$ 。

对于根据模数哈希函数的定义，我们得到两个哈希函数：

$$
H_1(T)=\sum_{k=0}^{n-1}ord(t_k)\times B_1^{n-1-k}\mod M_1\newline
H_2(T)=\sum_{k=0}^{n-1}ord(t_k)\times B_2^{n-1-k}\mod M_2
$$

#### 预计算

为了加快计算速度，我们可以预先计算好模式字符串的哈希值 $H(P)$ 与窗口哈希值 $H(T[0:m])$ 。

对于预计算的哈希函数，我们使用[秦九韶算法]({{< ref "HornerAlgorithm.md" >}})，这点会体现到代码实现中。

##### 模式串哈希值

$$
ph_1 = H_1(P) = \sum_{k=0}^{m-1}ord(p_k)\times B_1^{m-1-k}\mod M_1\newline
ph_2 = H_2(P) = \sum_{k=0}^{m-1}ord(p_k)\times B_2^{m-1-k}\mod M_2
$$

##### 窗口哈希值（索引为0）

$$
wh_1 = H_1(T[0:m]) = \sum_{k=0}^{m-1}ord(t_k)\times B_1^{m-1-k}\mod M_1\newline
wh_2 = H_2(T[0:m]) = \sum_{k=0}^{m-1}ord(t_k)\times B_2^{m-1-k}\mod M_2
$$

##### 预计算基数幂

$$
p1 = B_1^{m-1}\mod M_1\newline
p2 = B_2^{m-1}\mod M_2
$$

#### 滚动哈希更新公式

从位置 $i$ 到 $i+1$ 的哈希更新：

$$
wh_1^{(i+1)} = (wh_1^{(i)}-ord(t_i)\cdot p_i)\times B_1+ord(t_{i+m})\mod M_1\newline
wh_2^{(i+1)} = (wh_2^{(i)}-ord(t_i)\cdot p_i)\times B_2+ord(t_{i+m})\mod M_2
$$

#### 修正负值

由于滚动哈希的计算（模运算）结果可能出现负值，因此需要修正为非负值。  
所以当 $wh_1^{(i+1)}$ 或 $wh_2^{(i+1)}$ 出现负值时，需要将其修正为 $wh_1^{(i+1)}+M_1$ 或 $wh_2^{(i+1)}+M_2$ 。

#### 哈希匹配

当 $wh_1^{(i)} = ph_1$ 且 $wh_2^{(i)} = ph_2$ 时，完成匹配。

#### 字符验证

哪怕使用双哈希，也不一定能完全保证不发生哈希冲突，为了保险，需要加入验证步骤对每个字符进行检验：

$$
Verify(i) = \bigwedge_{k=0}^{m-1} (t_{i+k} = p_k)
$$

### 代码实现

根据上述数学过程，我们可以用C++实现Rabin-Karp算法：

```c++
// Rabin-Karp子串搜索算法
int rk(char* T, int n, char* P, int m) {
    if (m == 0) return 0;
    if (n < m) return -1;

    ll ph1=0, ph2=0, wh1=0, wh2=0, p1=1, p2=1;
    for (int i=0; i<m; i++) {
        ph1 = (ph1*B1 + P[i]) % M1;
        ph2 = (ph2*B2 + P[i]) % M2;
        wh1 = (wh1*B1 + T[i]) % M1;
        wh2 = (wh2*B2 + T[i]) % M2;
        if (i) p1 = (p1*B1) % M1, p2 = (p2*B2) % M2;
    }

    for (int i=0; i<=n-m; i++) {
        if (wh1 == ph1 && wh2 == ph2) {
            int j = 0;
            while (j < m && T[i+j] == P[j]) j++;
            if (j == m) return i;
        }
        if (i < n-m) {
            wh1 = (B1*(wh1 - T[i]*p1) + T[i+m]) % M1;
            wh2 = (B2*(wh2 - T[i]*p2) + T[i+m]) % M2;
            if (wh1 < 0) wh1 += M1; if (wh2 < 0) wh2 += M2;
        }
    }
    return -1;
}
```

定义字符串`str = "efsfdsgfsgrgtgdvsgf"`和子串`str1 = "dsg"`，传入并调用RK算法函数进行输出，得到：

```console
4
```

4即为字符串`str`中子串`str1`出现的起始索引，算法正确。

### 双哈希算法出现冲突的概率

$$
\frac {1}{1000000007 \times 1000000009} \approx 10^{-18}
$$

这个概率堪比从地球上所有的沙子（约$7.5 × 10^{18}$粒）中挑选出一粒提前指定好的沙子，或是连续抛硬币60次全部为正面或反面（$2^{60} \approx 10^{18}$），在如此小的概率下，冲突已经可以被认定为不可能发生，更何况我们的代码添加了验证步骤，所以哈希冲突概率为**0**。