---
title: "二分查找的原理及实现"
date: 2025-10-29
tags: ["算法","二分查找"]
categories: ["算法原理"]
draft: false
math: true
---

## 二分查找

二分查找（Binary Search）是一种在数组中查找某一特定元素的搜索算法。它属于一种折半搜索算法，每次查找都通过折半的方式缩小查找范围，直到找到目标元素或确定查找范围为空。它与数学上的二分法思想类似。

### 算法步骤

>核心思想：折半查找，找不到就继续折半。

**大前提**：数组必须是**有序的**，无序数组需要先排序。

1. 设置两个指针，$low$ 和 $high$，分别指向数组的第一个元素和最后一个元素。
2. 计算中间位置 $mid = \lfloor \dfrac{(low + high)} {2} \rfloor$ ，并判断目标元素是否在该位置上。
3. 如果目标元素等于数组中元素的值，则查找成功，返回该元素的下标；否则，根据目标元素与中间元素的大小关系，移动指针 $low$ 或 $high$ ，并重复步骤2。
4. 直到 $low$ 和 $high$ 相遇后仍未找到（$low > high$），查找失败，返回-1。

根据这些步骤，很容易写出二分查找的代码：
- 先定义一个返回值变量，初始化为-1。
- 循环条件是 $low \leq high$ ，表示指针移动的范围。
- 中间位置 $mid = \lfloor \dfrac{(low + high)} {2} \rfloor$ 。
    - 为什么是向下取整？因为在C/C++中，整型截断小数默认**向下取整**，所以这里用了向下取整来计算中间位置。
- 判断要查找的目标元素 $key$ 是否在中间位置上，如果是，则返回该位置的下标；如果大于中间值，把左指针 $low$ 指向中间位置的右边一个元素；如果小于中间值，把右指针 $high$ 指向中间位置的左边一个元素，循环往复，直到找到目标元素或指针相遇。
- 返回找到的元素的下标，如果没有找到，则返回-1。

```c++
int binarySearch(int *arr, int low, int high, int key) {
    int res = -1;
    while (low <= high) {
        int mid = low + (high - l) / 2; //与(low+high)/2等价，但是防止溢出
        if (arr[mid] == key) {
            res = mid;
            break;
        } else if (arr[mid] < key)
            low = mid + 1;
        else {
            high = mid - 1;
        }
    }
    return res;
}
```

### 时间复杂度分析

二分查找算法的时间复杂度平均为 $O(\log n)$ ，最好情况为 $O(1)$，最坏情况为 $O(\log n)$，其中 $n$ 为数组的长度。

#### 证明

设数组元素有 $n$ 个，每次迭代则搜索范围减半：

- 第一次迭代：剩余 $\frac{n}{2}$ 个元素
- 第二次迭代：剩余 $\frac{n}{2^2}$ 个元素
- 第三次迭代：剩余 $\frac{n}{2^3}$ 个元素
- ...
- 第 $k$ 次迭代：剩余 $\frac{n}{2^k}$ 个元素

当剩余元素个数为 $1$ 时，$\dfrac{n}{2^k} = 1$，所以 $k = \log_2 n$ 。

所以，二分查找算法的时间复杂度为 $O(\log n)$ 。